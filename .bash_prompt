# Automatically trim long paths in the prompt (requires Bash 4.x)
PROMPT_DIRTRIM=2

set_prompts() {
  
  local blue="" purple="" reset="" gray=""
  
  if [ -x /usr/bin/tput ] && tput setaf 1 &> /dev/null; then
    tput sgr0 # Reset colors
    
    reset=$(tput sgr0)
    
    blue=$(tput setaf 4)
    purple=$(tput setaf 5)
    gray=$(tput setaf 8)
    
    
  else
    
    reset="\e[0m"
    
    blue="\e[1;34m"
    purple="\e[1;35m"
    gray="\e[1;38m"
    
  fi
  
  function prompt_git() {
    
    # check if we're in a git repo. (fast)
    git rev-parse --is-inside-work-tree &>/dev/null || return
    
    # get the status to check if dirty (fast)
    gitstatus=$(git status --porcelain | cut -d' ' -f2)
    
    # check for what branch we're on. (fast)
    #   if… HEAD isn’t a symbolic ref (typical branch),
    #   then… get a tracking remote branch or tag
    #   otherwise… get the short SHA for the latest commit
    #   lastly just give up.
    branch="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
    git describe --all --exact-match HEAD 2> /dev/null || \
    git rev-parse --short HEAD 2> /dev/null || \
    echo 'unknown')";
    
    # dirty check. This is probably the fastest way.
    local clean=0 del=0 changed=0 new=0
    
    for line in $gitstatus; do
      if [ "$line" = "D" ]; then
        del=1
      elif [ "$line" = "M" ]; then
        changed=1
      else
        new=1
      fi
    done
    
    [ -z "$line" ] && clean=1
    
    [ $clean -eq 1 ] && branch="$branch"
    [ $clean -eq 0 ] && branch="$branch*"
    
    # output
    echo -e "($branch) ";
  }
  
  git_branch_info() {
    
    
    local gitstatus=$(git status --porcelain | cut -d' ' -f2)
    local branch="$(git rev-parse --abbrev-ref HEAD)" || branch="unnamed branch"
    
    local clean=0 del=0 changed=0 new=0
    
    for line in $gitstatus; do
      if [ "$line" = "D" ]; then
        del=1
      elif [ "$line" = "M" ]; then
        changed=1
      else
        new=1
      fi
    done
    
    [ -z "$line" ] && clean=1
    
    [ $clean -eq 1 ] && branch="$branch"
    [ $clean -eq 0 ] && branch="$branch*"
    
    # output
    print -n "($branch) "	
  }
  
  
  # ------------------------------------------------------------------
  # | Prompt string                                                  |
  # ------------------------------------------------------------------
  
  PS1="\[\033]0;\w\007\]"                                # terminal title (set to the current working directory)
  PS1+="\[$blue\]\w "                                    # working directory
  PS1+="\[$gray\]\$(prompt_git )"                        # git repository details
  PS1+="\[$reset$purple\]❯ \[$reset\]"
  
  export PS1
}


set_prompts
unset set_prompts