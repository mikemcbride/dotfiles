# This prompt inspired by gf3, sindresorhus, alrra, and mathiasbynens.
# but customized to me. <3

default_username='paulirish'


if which thefuck > /dev/null; then
    eval "$(thefuck --alias)"
fi;

# Automatically trim long paths in the prompt (requires Bash 4.x)
PROMPT_DIRTRIM=2

if [[ -n "$ZSH_VERSION" ]]; then  # quit now if in zsh
    return 1 2> /dev/null || exit 1;
fi;


if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
    export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
    export TERM=xterm-256color
fi


set_prompts() {

    local black="" blue="" bold="" cyan="" green="" orange="" \
          purple="" red="" reset="" white="" yellow="" gray=""

    local dateCmd=""

    if [ -x /usr/bin/tput ] && tput setaf 1 &> /dev/null; then

        tput sgr0 # Reset colors

        bold=$(tput bold)
        reset=$(tput sgr0)

        black=$(tput setaf 0)
        blue=$(tput setaf 4)
        cyan=$(tput setaf 6)
        green=$(tput setaf 2)
        orange=$(tput setaf 3)
        purple=$(tput setaf 5)
        red=$(tput setaf 9)
        violet=$(tput setaf 13)
        magenta=$(tput setaf 5)
        white=$(tput setaf 15)
        yellow=$(tput setaf 11)
        gray=$(tput setaf 8)
        

    else

        bold=""
        reset="\e[0m"

        black="\e[1;30m"
        blue="\e[1;34m"
        cyan="\e[1;36m"
        green="\e[1;32m"
        orange="\e[1;33m"
        purple="\e[1;35m"
        red="\e[1;31m"
        magenta="\e[1;31m"
        violet="\e[1;35m"
        white="\e[1;37m"
        yellow="\e[1;33m"
        gray="\e[1;38m"

    fi

    function prompt_git() {

        # check if we're in a git repo. (fast)
        git rev-parse --is-inside-work-tree &>/dev/null || return

        # [ -n "${s}" ] && s=" [${s}]";
        # echo -e "${1}${branchName}${2}$dirty";
        
        # get the status to check if dirty
        gitstatus=$(git status --porcelain | cut -d' ' -f2)
        
        # check for what branch we're on. (fast)
        #   if… HEAD isn’t a symbolic ref (typical branch),
        #   then… get a tracking remote branch or tag
        #   otherwise… get the short SHA for the latest commit
        #   lastly just give up.
        branch="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
            git describe --all --exact-match HEAD 2> /dev/null || \
            git rev-parse --short HEAD 2> /dev/null || \
            echo 'unknown')";

      	local clean=0 del=0 changed=0 new=0

      	for line in $gitstatus; do
      	  if [ "$line" = "D" ]; then
      	    del=1
      	  elif [ "$line" = "M" ]; then
      	    changed=1
      	  else
      	    new=1
      	  fi
      	done

      	[ -z "$line" ] && clean=1

      	[ $clean -eq 1 ] && branch="$branch"
      	[ $clean -eq 0 ] && branch="$branch*"

      	# output
      	echo -e "($branch) ";
    }
    
    git_branch_info() {


	local gitstatus=$(git status --porcelain | cut -d' ' -f2)
	local branch="$(git rev-parse --abbrev-ref HEAD)" || branch="unnamed branch"

	local clean=0 del=0 changed=0 new=0

	for line in $gitstatus; do
	  if [ "$line" = "D" ]; then
	    del=1
	  elif [ "$line" = "M" ]; then
	    changed=1
	  else
	    new=1
	  fi
	done

	[ -z "$line" ] && clean=1

	[ $clean -eq 1 ] && branch="$branch"
	[ $clean -eq 0 ] && branch="$branch*"

	# output
	print -n "($branch) "	
}



    # ------------------------------------------------------------------
    # | Prompt string                                                  |
    # ------------------------------------------------------------------

    PS1="\[\033]0;\w\007\]"                                # terminal title (set to the current working directory)
    PS1+="\[$blue\]\w "                                    # working directory
    PS1+="\[$gray\]\$(prompt_git )"                        # git repository details
    PS1+="\[$reset$purple\]❯ \[$reset\]"

    export PS1

    # ------------------------------------------------------------------
    # | Subshell prompt string                                         |
    # ------------------------------------------------------------------

    export PS2="❯ "

    # ------------------------------------------------------------------
    # | Debug prompt string  (when using `set -x`)                     |
    # ------------------------------------------------------------------

    # When debugging a shell script via `set -x` this tricked-out prompt is used.

    # The first character (+) is used and repeated for stack depth
    # Then, we log the current time, filename and line number, followed by function name, followed by actual source line

    # FWIW, I have spent hours attempting to get time-per-command in here, but it's not possible. ~paul
    export PS4='+ \011\e[1;30m\t\011\e[1;34m${BASH_SOURCE}\e[0m:\e[1;36m${LINENO}\e[0m \011 ${FUNCNAME[0]:+\e[0;35m${FUNCNAME[0]}\e[1;30m()\e[0m:\011\011 }'


    # shoutouts:
    #   https://github.com/dholm/dotshell/blob/master/.local/lib/sh/profile.sh is quite nice.
    #   zprof is also hot.

}



set_prompts
unset set_prompts